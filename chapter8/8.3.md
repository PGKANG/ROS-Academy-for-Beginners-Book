# 8.3 tf in c++
### 8.3.1 简介
前面内容我们介绍了TF的基本的概念和TF树消息的格式类型，我们知道，TF不仅仅是一个标准、话题，它还是一个接口。本节课我们就介绍c++中TF的一些函数和写法。
### 8.3.2 数据类型
C++中给我们提供了很多TF的数据类型，如下表：

|   名称    | 数据类型 |
| :------:   | :------:           |
| 向量               |   tf::Vector3 |
| 点   |  tf::Point  |
| 四元数   |  tf::Quaternion |
| 3*3矩阵（旋转矩阵）    |  tf::Matrix3x3|
| 位姿               |   tf::pose |
| 变换   |  tf::Transform  |
| 带时间戳的以上类型   | tf::Stamped<T> |
| 带时间戳的变换    |  tf::StampedTransform|

**易混注意：**虽然此表的最后带时间戳的变换数据类型为tf::StampedTransform,和上节我们所讲的geometry_msgs/TransformStamped.msg看起来很相似，但是其实数据类型完全不一样，tf::StampedTransform只能用在C++里，只是C++的一个类，一种数据格式，并不是一个消息。而geometry_msgs/TransformStamped.msg是一个message,它依赖于ROS，与语言无关，也即是无论何种语言，C++、Python、Java等等，都可以发送该消息。
### 8.3.3 数据转换

![](/pics/tf_translate.png)


在TF里有可能会遇到各种各样数据的转换，例如常见的四元数、旋转矩阵、欧拉角这三种数据之间的转换。tf in roscpp给了我们解决该问题的函数。详细源码在我们教学课程的代码包中。
首先在tf中与数据转化的数据都类型都包含在`#include<tf/tf.h>`头文件中，我们将与数据转换相关API都存在tf_demo中的coordinate_transformation.cpp当中，其中列表如下：
第一部分定义空间点和空间向量

| 编号 | 函数名称 | 函数功能 |
| :---: | :---: | :---: |
| 1.1 | tfScalar::tfDot\(const Vector3 &v1, const Vector3 &v2\) | 计算两个向量的点积 |
| 1.2 | tfScalar length\(\) | 计算向量的模 |
| 1.3 | Vector3 &normalize\(\) | 求与已知向量同方向的单位向量 |
| 1.4 | tfScalar::tfAngle\(const Vector3 &v1, const Vector3 &v2\) | 计算两个向量的夹角 |
| 1.5 | tfScale::tfDistance\(const Vector3 &v1, const Vector3 &v2\) | 计算两个向量的距离 |
| 1.6 | tfScale::tfCross\(const Vector3 &v1,const Vector3 &v2\) | 计算两个向量的乘积 |

如下

    #include <ros/ros.h>
    #include <tf/tf.h>
    //退出用：ctrl+z
    int main(int argc, char** argv){
    //初始化
    ros::init(argc, argv, "coordinate_transformation");
    ros::NodeHandle node;
    tf::Vector3 v1(1,1,1);
    tf::Vector3 v2(1,0,1);
    //第1部分，定义空间点和空间向量
    std::cout<<"第1部分，定义空间点和空间向量"<<std::endl;
    //1.1 计算两个向量的点积
    std::cout<<"向量v1:"<<"("<<v1[0]<<","<<v1[1]<<","<<v1[2]<<"),";
    std::cout<<"向量v2:"<<"("<<v2[0]<<","<<v2[1]<<","<<v2[2]<<")"<<std::endl;
    std::cout<<"两个向量的点积："<<tfDot(v1,v2)<<std::endl;
    //1.2 计算向量的模
    std::cout<<"向量v2的模值:"<<v2.length()<<std::endl;
    //1.3 求与已知向量同方向的单位向量
    tf::Vector3 v3;
    v3=v2.normalize();
    std::cout<<"与向量v2的同方向的单位向量v3:"<<"("<<v3[0]<<","<<v3[1]<<","<<v3[2]<<")"<<std::endl;
    //1.4 计算两个向量的夹角
    std::cout<<"两个向量的夹角(弧度):"<<tfAngle(v1,v2)<<std::endl;
    //1.5 计算两个向量的距离
    std::cout<<"两个向量的距离:"<<tfDistance2(v1,v2)<<std::endl;
    //1.6 计算两个向量的乘积
    tf::Vector3 v4;
    v4=tfCross(v1,v2);
    std::cout<<"两个向量的乘积v4:"<<"("<<v4[0]<<","<<v4[1]<<","<<v4[2]<<")"<<std::endl;```


你好


### 8.3.4 TF类
##### tf::TransformBroadcaster类

    transformBroadcaster()
    void sendTransform(const StampedTransform &transform)
    void sendTransform(const std::vector<StampedTransform> &transforms)
    void sendTransform(const geometry_msgs::TransformStamped &transform)
    void sendTransform(const std::vector<geometry_msgs::TransformStamped> &transforms)
    
这个类在前面讲TF树的时候提到过，这个broadcaster就是一个publisher,而sendTransform的作用是来封装publish的函数。在实际的使用中，我们需要在某个Node中构建tf::TransformBroadcaster类，然后调用sendTransform(),将transform发布到`/tf`的一段transform上。`/tf`里的transform为我们重载了多种不同的函数类型，具体如上。

##### tf::TransformListener类

    void lookupTranform(const std::string &target_frame,const std::string &source_frame,const ros::Time &time,StampedTransform &transform)const
    bool canTransform()
    bool waitForTransform()const
    
上一个类是向`/tf`上发的类，那么这一个就是从`/tf`上接收的类。首先看lookuptransform()函数，第一个参数是目标坐标系，第二个参数为源坐标系，也即是得到从源坐标系到目标坐标系之间的转换关系，第三个参数为查询时刻，第四个参数为存储转换关系的位置。值得注意，第三个参数通常用`ros::Time（0）`,这个表示为最新的坐标转换关系，而`ros::time::now`则会因为收发延迟的原因，而不能正确获取当前最新的坐标转换关系。canTransform()是用来判断两个transform之间是否连通，waitForTransform()const是用来等待某两个transform之间
的连通。




