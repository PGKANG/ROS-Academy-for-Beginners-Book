# 2.4 CMakeLists.txt文件
`CMakeLists.txt`原本是Cmake编译系统的规则，而catkin编译系统沿用了CMake的编译风格，只是在一些细节上进行了扩展。所以在写法上，catkin的`CMakeLists.txt`与CMake的基本一致。 

这个文件直接规定了这个package要依赖哪些package，要编译生成哪些目标，如何编译等等问题。所以`CMakeLists.txt`非常重要，它指定了由源码到目标文件的规则，catkin编译系统在工作时首先会找到每个package下的`CMakeLists.txt`，然后按照规则来编译构建。


### 2.4.1 CMakeLists总体结构和顺序
`CMakeLists.txt`文件一定要遵守以下格式，否则package将无法正确的编译，需要注意以下格式的顺序。
1. CMake的版本号 (cmake_minimum_required)
2. 项目名称 (project())
3. 找到其他编译需要的CMake/Catkin的package(find_package())
4. 打开Python Module的支持 (catkin_python_setup())
5. 添加自定义Message/Service/Action文件 (add_message_files(), add_service_files(), add_action_files())
6. 生成自定义message/service/action (generate_messages())
7. 指定package编译信息输出 (catkin_package())
8. 生成库/生成可执行文件/链接 (add_library()/add_executable()/target_link_libraries())
9. 生成测试 (catkin_add_gtest())
10. 安装规则 (install())

### 2.4.2 CMakeLists例子
以turtlesim为例，`CMakeLists.txt`的写法如下
```
cmake_minimum_required(VERSION 2.8.3)  #CMake至少为2.8.3版
project(turtlesim)  #项目(package)名称为turtlesim

find_package(catkin REQUIRED COMPONENTS geometry_msgs message_generation rosconsole roscpp roscpp_serialization roslib rostime std_msgs std_srvs) # 依赖的其他pacakge

find_package(Qt5Widgets REQUIRED)
find_package(Boost REQUIRED COMPONENTS thread)

include_directories(include ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS}) # 指定C/C++的头文件路径
link_directories(${catkin_LIBRARY_DIRS})  #指定链接库的路径

add_message_files(DIRECTORY msg FILES
                  Color.msg Pose.msg)   #自定义msg文件
add_service_files(DIRECTORY srv FILES
                  Kill.srv
                  SetPen.srv
                  Spawn.srv
                  TeleportAbsolute.srv
                  TeleportRelative.srv)  #自定义srv文件
generate_messages(DEPENDENCIES geometry_msgs std_msgs std_srvs) #

catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs)

set(turtlesim_node_SRCS
  src/turtlesim.cpp
  src/turtle.cpp
  src/turtle_frame.cpp
)
set(turtlesim_node_HDRS
  include/turtlesim/turtle_frame.h
)

qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS})


add_executable(turtlesim_node ${turtlesim_node_SRCS} ${turtlesim_node_MOCS})
target_link_libraries(turtlesim_node Qt5::Widgets ${catkin_LIBRARIES} ${Boost_LIBRARIES})
add_dependencies(turtlesim_node turtlesim_gencpp)

add_executable(turtle_teleop_key tutorials/teleop_turtle_key.cpp)
target_link_libraries(turtle_teleop_key ${catkin_LIBRARIES})
add_dependencies(turtle_teleop_key turtlesim_gencpp)
add_executable(draw_square tutorials/draw_square.cpp)
target_link_libraries(draw_square ${catkin_LIBRARIES} ${Boost_LIBRARIES})
add_dependencies(draw_square turtlesim_gencpp)
add_executable(mimic tutorials/mimic.cpp)
target_link_libraries(mimic ${catkin_LIBRARIES})
add_dependencies(mimic turtlesim_gencpp)

install(TARGETS turtlesim_node turtle_teleop_key draw_square mimic
  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})

install(DIRECTORY images
  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
  FILES_MATCHING PATTERN "*.png" PATTERN "*.svg")
```

### 2.4.2 catkin软件包名称
继而需要指定CMake工程名，一般取作包名。例如我们的项目名叫做robot_brain，则project(robot_brain)，而在CMake中，可以在CMake文本中使用变量${PROJECT_NAME}来引用项目名称。

##### 3. 查找相关包
接下来我们要用find_package指令来指定在构建项目过程中依赖了哪些其他的包，在ROS中，catkin必备依赖,所以我们写上catkin REQUIRED：find_package(catkin REQUIRED)。在此基础上，如果我们还需要依赖其他包（或者组件），我们就在 上述的包后面继续添加包（组件）名即可：find_package(catkin REQUIRED COMPONENTS nodelet) 或者写成find_package(catkin REQUIRED)/find_package(nodelet REQUIRED)。

##### 4. catkin_package()
catkin_package()是一个catkin提供的CMake宏，用于将catkin特定的信息信息输出到构建系统上，用于生成pkg配置文件以及CMake文件。
这个命令必须在add_library()或者add_executable()之前调用，该函数有5个可选参数：
(1) INCLUDE_DIRS - 导出包的include路径
(2) LIBRARIES - 导出项目中的库
(3) CATKIN_DEPENDS - 该项目依赖的其他catkin项目
(4) DEPENDS - 该项目所依赖的非catkin CMake项目。
(5) CFG_EXTRAS - 其他配置选项

##### 5. 指定构建目标
构建目标可以有多种形式，但通常主要有以下两种：
(1) 执行文件目标 - 可以运行的程序
(2) 库目标 - 可在构建和/或运行时给可执行目标使用的库

##### 6. 消息、服务和响应
消息（.msg），服务（.srv）和响应（.action）文件在ROS包构建和使用之前需要一个特殊的预处理器构建步骤。 这些宏的要点是生成编程语言特定的文件，以便可以利用其选择的编程语言中的消息，服务和动作。 构建系统将使用生成器（例如gencpp，genpy，genlisp等）生成绑定。
提供了三个宏来分别处理消息，服务和响应：
(1) add_message_files
(2) add_service_files
(3) add_action_files
而在之后必须在下面写下面宏，catkin时候会在devel的include文件夹中生成对应的头文件：generate_messages()

##### 7. 启动模块支持
如果catkin包使用一些Python模块，您应该创建一个setup.py文件，并在调用catkin_python_setup（）之前调用generate_messages（）和catkin_package（）。

##### 8. 单位测试
有一个catkin-specific宏用于处理名为catkin_add_gtest（）的基于gtest的单元测试。catkin_add_gtest（myUnitTest test / utest.cpp）。

##### 9. 可选步骤：指定可安装的目标
构建后，构建目标通常被放置在catkin工作区中。但有时候我们希望将目标安装到系统其他地方（有关安装路径的信息可以在REP 122中找到），以便其他人或本地文件夹可以使用它们来测试。换句话说，如果你想要做一个“make install”的代码，你需要指定目标应该生成到哪里。
这是使用CMake install()函数作为参数完成的：
(1) 目标 - 目标是安装
(2) ARCHIVE DESTINATION - 静态库和DLL（Windows）.lib存根
(3) LIBRARY DESTINATION - 非DLL共享库和模块
(4) RUNTIME DESTINATION - 可执行目标和DLL（Windows）样式共享库
除了这些标准目标，一些文件必须安装到特殊文件夹。即一个包含Python绑定的库必须安装到不同的文件夹中才能在Python中导入：
install(TARGETS python_module_library
ARCHIVE DESTINATION ${CATKIN_PACKAGE_PYTHON_DESTINATION}
LIBRARY DESTINATION ${CATKIN_PACKAGE_PYTHON_DESTINATION}
)

### 2.2.3 package.xml写法
package.xml实际上是一个程序包的描述文件。当你的package里已经包含配置文件(package.xml)，ROS能够找到它。执行：rospack find [包名称]。应该注意到我们刚才所创建的package.xml依赖于 roscpp 和 std_msgs.而catkin恰恰是利用这些依赖项来配置所创建的package。

##### 1. 基本结构
使用<package>标签作为根标记文件。
<package>
</ package>

##### 2. 所需标签
(1) <name> - 包的名称
(2) <version> - 包的版本号（需要3个点分隔的整数）
(3) <description> - 包装内容的描述
(4) <maintainer> - 维护包的人员的名称
(5) <license> - 发布代码的软件许可证（例如GPL，BSD，ASL）。

##### 3. 依赖关系
(1) <buildtool_depend>构建工具依赖关系指定此软件包需要构建自身的构建系统工具。通常唯一的构建工具是catkin。在交叉编译场景中，构建工具依赖关系用于执行编译的架构。
(2) <build_depend>构建依赖关系指定构建此包所需的包。在构建时需要这些软件包中的任何文件时才是这种情况。这可以包括这些包在编译时的标头，链接到这些包的库或在构建时需要任何其他资源（特别是当这些包在CMake 中是find_package（））时）。在交叉编译场景中，构建依赖关系针对目标体系结构。
(3) <run_depend>运行依赖关系指定在此程序包中运行代码所需的软件包，或针对此软件包构建库。在这种情况下，您依赖于共享库或将其头部包含在此包中的公头中（特别是当这些包在CMake 中的catkin_package（）中声明为（CATKIN_DEPENDS）时）。

### 2.2.4 命令介绍
##### 1. ROS文件系统命令
(1) rospack是用于从文件系统中提取功能包信息的命令工具，用于执行很多打印功能包信息的命令，其用法 rospack <command> [options] [package]
(2) rosstack是用于从文件系统中提取功能包信息集的命令工具，用于执行一系列与功能包集信息的命令，其用法 rosstack [options] <command> [stack]
(3) roscd是用于改变路径到相应的功能包或者功能包集的命令工具，其用法 roscd [package[/subdir]]
(4) rosls是用于罗列相应的功能包、功能包集文件夹的命令包，其用法 rosls [package[/subdir]]
(5) roscreate-pkg是用于创建新的功能包，其用法 roscreate-pkg [package_name] 或者 roscreate-pkg [package_name] [depend1] [depend2] [depend3]
(6) roscreate-stack是用于创建一个新的ROS功能包集，其用法类似roscreat-pkg
(7) rosdep是用于安装ROS功能包系统依赖文件
(8) rosmake是用于编译安装一个ROS功能包，其用法 rosmake [[package] 或者 编译多个 rosmake [package1] [package2] [package3]
(9) roswtf是用于显示ROS系统或者启动文件的错误或者警告信息
(10) rosdep是用于显示功能包结构和依赖文件信息，其用法 rosdep [options]

##### 2. ROS核心命令
(1) roscore是用于运行基于ROS系统必须的节点和程序的集合。至少要有一个roscore在运行才能保证节点能够正常通信。
(2) rosmsg/rossrv是用于显示消息或者服务的结构定义。
(3) rosrun是用于不必改变到相应目录就可以执行任意一个功能包下的可执行文件，其用法 rosrun package executable。
(4) rosnode是用于显示关于ROS节点的调试信息。
(5) roslaunch是用于通过SSH和在参数服务器上设置参数来局部和远程启动ROS节点。通过调用一个或者多个XML配置文件来完成启动过程。
(6) rostopic是用于显示ROS主题调试信息的工具。
(7) rosparam是用于获取和设置参数服务器上用YAML编码的文件的工具。
(8) rosservice是用于列表和查询ROS服务器的工具。