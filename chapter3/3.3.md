# 3.3 Service && Srv
### 3.3.1 Service
上节课我们介绍了ROS的通信方式中的topic(主题)通信，我们知道topic是ROS中的一种单向的异步通信方式。这节我们来介绍ROS通信中的另一种通信方式——service(服务)，这种方式和topic有着明显区别的一点就是service通信是双向的，它不仅可以发送消息，同时还会有反馈，也即是services在节点发送一个request，要等待接收一个reply，这样才完成了整个服务通信。
### 3.3.2 工作原理
##### 简介
service与topic方式不同的是，有些时候单向的通信满足不了通信要求，比如当一些节点需要的只是一瞬时的数据时，如果用topic通信方式时就会消耗大量不必要的系统资源，被请求的节点频繁的向目标节点输出数据，而目标节点只接收自己某个时刻需要的数据，这样就占据了大量的系统资源，造成系统的低效率高功耗。

如何能够弥补这个弊端？是否定义双节点双向topic就可行？这个问题也许是众多初学者都会想到的，理论上来说是可以的，但实际操作起来就会非常笨重，编程起来非常麻烦，效率并不高，在这样的情况下，作为双向通信的service方式，就十分高效的解决了上述问题。
结构示意图如下：

![](/pics/service_structure.png)

##### 过程
观察上图就是service同步通信方式，节点之间通过request-reply方式通信。过程步骤就是，首先NOde A 发送一个请求给`/service`,注意同步的概念，此时Client在原地等待Reply，等到Node B 接受到请求，就开始处理服务请求。然后`/service`发送Reply给还在等待的Client，这一段时间是"阻塞"状态，当Node A接到Reply，就开始进行下一步操作，完成通信。这样就适合上述例子中的通信要求，没有繁琐的订阅发布，没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。

### 3.3.3 topic VS service
学习了topic和service,我们观察一下这两种通信方式的异同，对比来加深我们对两者的理解和认识，见下表：


|        | Topic | Service|
| :------: | :------:  |:------: |
| 通信方式  |  异步通信 |同步通信|
| 实现原理  |  TCP/IP  |TCP/IP| 
| 通信模型  |  Publish-Subscribe |Request-Reply   |
| 映射关系  |  Publish-Subscribe(多对多)|Request-Reply（多对一）|
|特点    |  接受者收到数据会回调（Callback）  |远程过程调用（RPC）服务器端的服务|
|应用场景   | 连续、高频的数据发布 |偶尔使用的功能/具体的任务|
|举例|激光雷达、里程计发布数据  |开关传感器、拍照、逆解计算|

**注意：**远程过程调用(RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。


### 3.3.4 参数命令

在实际应用中，service通信方式的命令时`rosservice`，具体的命令参数如下表：


|    rosservice 命令    | 作用 |
| :------:   | :------:           |
| `rosservice list`  |   显示服务列表 |
| `rosservice info`   |  打印服务信息  |
| `rosservice type`   |  打印服务类型 |
| `rosservice uri `    |  打印服务ROSRPC uri|
| `rosservice find`     |  按服务类型查找服务  |
|`rosservice call`    |  使用所提供的args调用服务 |
|`rosservice args` |  打印服务参数  |

### 3.3.5 Srv
类似msg，srv(服务文件)是用来描述服务（service）数据类型的，service通信的数据格式定义在*.srv中。它声明了一个服务包括请求(request)和响应（reply）。而与msg不同的就是，srv包含的这两个部分——request和reply。其格式声明如下：

**举例：**

my_pkg/srv/DetectHUman.srv

    bool start_detect
    ---
    my_pkg/HumanPose[] pose_data
    
my_pkg/msg/HumanPose.msg

    std_msgs/Header header
    string uuid
    int32 number_of_joints
    my_pkg/JointPose[]joint_data
    
my_pkg/msg/JointPose.msg

    string joint_name
    geometry_msgs/Pose pose
    floar32 confidence
    
观察上例，srv文件格式是很固定的，第一行是请求的格式，中间用**---**隔开，第三行是应答的格式。总体呈现上面问，下面答，一问一答的格式特点。注意srv里的文件是msg，因为srv只能嵌套msg，因为不能嵌套自己本身，这样也方便系统解析。


具体的操作指令如下表：

|    rossrv 命令    | 作用 |
| :------:   | :------:           |
| `rossrv show`  |  显示服务描述|
| `rossrv list`   | 列出所有服务  |
| `rossrv md5`   |  显示服务md5sum |
| `rossrv package `    |  列出包中的服务|
|`rossrv packages`    |  列出包含服务的包|

#### 修改部分文件
定义完了msg、srv文件，还有重要的一个步骤就是修改package.xml和修改CMakeList.txt。这些文件需要添加一些必要的依赖等，例如：

    <build_depend>**message_generation**</build_depend>
    <run_depend>**message_runtime**</run_depend>
    
上述文本中“**”所引就是新添加的依赖。又例如：

    find_package(...roscpp rospy std_msgs **message_generation**)
    catkin_package(
    ...
    CATJIN_DEPENDS **message_runtime** ...
    ...)
    
    add_message_file(
    FILES
    **DetectHuman.srv**
    **HumanPose.msg**
    **JointPos.msg**)
    
    **generate_messages(DEPENDENCIES std_msgs)**
    
添加的这些内容指定了srv或者msg在编译或者运行中需要的依赖。具体的作用可不深究，我们需要了解的是，无论我们自定义了srv,还是msg，修改上述部分添加依赖都是必不可少的。
    
#### 小结
本节我们详细介绍了service通信方式，建议与topic通信方式进行对比记忆，这样我们能更深的理解这两种通信方式，也能在以后的学习工作中更加合理使用每个通信方式，获得更高的效率。


