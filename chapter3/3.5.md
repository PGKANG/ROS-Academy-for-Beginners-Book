# 3.5 Service 

## 3.5.1 Service
上节课我们介绍了ROS的通信方式中的topic(主题)通信，我们知道topic是ROS中的一种单向的异步通信方式。这节我们来介绍ROS通信中的另一种通信方式——service(服务)。这种方式和topic方式有着明显区别，就是topic通信是单向的而service通信是双向的，它不仅可以发送消息，同时还会有反馈，也即是services在节点发送一个request，要等待接收一个reply，这样通过类似“握手应答”的机制完成整个服务通信。
## 3.5.2 工作原理
### 简介
上文也提到了，service与topic方式不同的是通信是否可逆。有些时候单向的通信满足不了通信要求，比如当一些节点需要的只是一瞬时的数据时，如果用topic通信方式时就会消耗大量不必要的系统资源，被请求的节点频繁的向目标节点输出数据，而目标节点只接收自己某个时刻需要的数据，这样就占据了大量的系统资源，造成系统的低效率高功耗。

如何能够弥补这个弊端？是否定义双节点双向topic就可行？这个问题也许是众多初学者都会想到的，理论上来说是可以的，但实际操作起来就会非常笨重，编程起来非常麻烦，效率并不高。在这样的情况下，作为双向通信的service方式，就十分高效的解决了上述问题。
结构示意图如下：

![](/pics/service_structure.png)

### 过程
观察上图就是service同步通信方式，节点之间通过request-reply方式通信。过程步骤就是，首先NOde A 发送一个请求给`/service`,注意同步的概念，此时Client在原地等待Reply，等到Node B 接受到请求，就开始处理服务请求。然后`/service`发送Reply给还在等待的Client，这一段时间是"阻塞"状态，当Node A接到Reply，就开始进行下一步操作，完成通信。这样就适合上述例子中的通信要求，没有繁琐的订阅发布，没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。

## 3.5.3 topic VS service
学习了topic和service,我们观察一下这两种最常用通信方式的异同，对比加深我们对两者的理解和认识，具体见下表：


|   名称     | Topic | Service|
| :------: | :------:  |:------: |
| 通信方式  |  异步通信 |同步通信|
| 实现原理  |  TCP/IP  |TCP/IP| 
| 通信模型  |  Publish-Subscribe |Request-Reply   |
| 映射关系  |  Publish-Subscribe(多对多)|Request-Reply（多对一）|
|特点    |  接受者收到数据会回调（Callback）  |远程过程调用（RPC）服务器端的服务|
|应用场景   | 连续、高频的数据发布 |偶尔使用的功能/具体的任务|
|举例|激光雷达、里程计发布数据  |开关传感器、拍照、逆解计算|

**注意：**远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。


## 3.5.4 操作命令

在实际应用中，service通信方式的命令时`rosservice`，具体的命令参数如下表：


|    rosservice 命令    | 作用 |
| :------:   | :------:           |
| `rosservice list`  |   显示服务列表 |
| `rosservice info`   |  打印服务信息  |
| `rosservice type`   |  打印服务类型 |
| `rosservice uri `    |  打印服务ROSRPC uri|
| `rosservice find`     |  按服务类型查找服务  |
|`rosservice call`    |  使用所提供的args调用服务 |
|`rosservice args` |  打印服务参数  |

## 3.5.5 测试实例
1. 首先依然是打开我们教材的模拟场景`roslaunch robot_sim_demo robot_spawn_launch`。
2. 输入`rosservice list`，查看当前运行的服务。
3. 随机选择`/gazebo/delete light`服务，观察名称，是删除光源的操作。
4. 输入`rosservice info /gazebo/delete light`查看属性信息。可以看到信息，Node：/gazebo，Type：gazebo_msgs/DeleteLight, Args：Light_name。这里的类型type也就是下文介绍的srv,传递参数Light_name
5. 输入`rosservice call /gazebo/delete light sun`,这里的sun 是参数名，使我们模拟场景中的唯一光源太阳。操作完成后可以看到场景中的光线消失。
6. 可以看到终端的回传信息：success: True和sun successfully deleted。这就是双向通信的信息反馈，通知操作已经成功完成。
    
## 小结
本节我们详细介绍了service通信方式，建议与topic通信方式进行对比记忆，这样我们能更深的理解这两种通信方式，也能在以后的学习工作中更加合理使用每个通信方式，获得更高的效率。


